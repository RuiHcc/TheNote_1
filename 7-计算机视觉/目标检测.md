图像分类：假设图像中只有一个主要物体对象，我们只关注如何识别其类别

目标检测：**类别 + 位置
	很多时候图像里有多个我们感兴趣的目标，我们不仅想知道它们的类别，还想得到它们在图像中的具体位置。
	
边缘框：bounding box 表征目标的位置
一个边框可以用四个数字来定义：
	（左上x，左上y，右下x，右下y）/ （左上x，左上y，宽，高）

目标检测数据集：
每一行表示一个物体：[[锚框代码]]
	图片文件名，物体类别，边缘框
COCO（cocodataset.org）
	80类别物体，330k图片，1.5M个物体

批量(batch_size)的问题：可能一张图里面有多个物体，一般做法是设置一个上限数量

计算机视觉-OPENCV 


## 锚框 Anchor box
目标检测算法是基于锚框，锚框用来预测物体位置，boundingbox是真实位置
	提出多个被称为锚框的区域（边缘框）
	预测每个锚框里是否含有关注的物体
	如果是，预测从这个锚框到真实边缘框的偏移

IoU- 交并比：也是我们训练的目标，的到高IOU的预测模型
IoU用来计算两个框之间的相似度
	0表示无重叠，1表示重合
	J(A,B) = |A交B| / |A并B|

赋予锚框标号：
每个锚框是一个训练样本
将每个锚框，要么标注成背景，要么关联上一个真实边缘框
我们可能会生成大量的锚框
	这会导致大量的负类样本
	![[Pasted image 20250414110140.png | 500]]
	边缘框1234，可以理解为图片中共有4个物体
	1~9为生成的锚框，两者构成一个矩阵，其元素为IOU；那么每一次我都选取一个IOU最大值对应的锚框来做为某一个物体的预测框

使用 非极大值抑制(NMS)输出
	每个锚框预测一个边缘框
	NMS可以合并相似的预测
		选中是非背景类的最大预测值（预测概率p，也称置信度）
		去掉所有其他和它IOU值大于$\theta$ 的预测框
		重复上述过程直到所有的预测要么被选中要么被去掉  

>总结：
>一类目标检测算法是基于锚框来预测的
>首先生成大量锚框，并赋予标号，每个锚框作为一个样本进行**训练**
>在**预测**时，使用NMS来去掉冗余的预测

目前来说anchor效果不错，算法也较多；但是不用锚框也可以

训练的时候，是有真实的边缘框，锚框是算法生成的用来预测真实的边缘框，然后用nms去除多余的框；在训练的时候，有真实的边缘框，所以给锚框标号；预测的时候就没有，直接预测


## 算法实现
### 1 生成多个锚框
[PyTorch深度学习中锚框生成与计算详解,-CSDN博客](https://blog.csdn.net/m0_58664541/article/details/134527300?ops_request_misc=&request_id=&biz_id=102&utm_term=%E9%94%9A%E6%A1%86%E7%9A%84%E5%AE%BD%E9%AB%98%E8%AE%A1%E7%AE%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-134527300.142^v102^pc_search_result_base2&spm=1018.2226.3001.4187)
假设输入图像的高度为ℎ，宽度为𝑤。以图像的每个像素为中心生成不同形状的锚框：_缩放比_ 为𝑠∈(0,1]，_宽高比_ 为𝑟>0。
那么锚框的宽和高为：$hs\sqrt{r}$  和 $hs/\sqrt{r}$ 
![[Pasted image 20250414160211.png]]
![[Pasted image 20250414160229.png]]
w和h是原图像的宽和高，w0和h0是我们得到的锚框的宽和高，计算结果和教材上的结果是相同的。

在实践中，我们只考虑包含𝑠1或𝑟1的组合：也就是说，以同一像素为中心的锚框的数量是𝑛+𝑚−1。整个输入图像，将共生成𝑤ℎ(𝑛+𝑚−1)个锚框。



